<div align="center">

<br/>

```
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â•šâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•”â•â•â•   â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•
â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•     â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•šâ•â•â•
```

### Enterprise Expense Management â€” Microservices Architecture

<br/>

[![Build & Test](https://github.com/joshivignesh/expenseflow-microservices/actions/workflows/ci.yml/badge.svg)](https://github.com/joshivignesh/expenseflow-microservices/actions/workflows/ci.yml)
[![Deploy](https://github.com/joshivignesh/expenseflow-microservices/actions/workflows/cd.yml/badge.svg)](https://github.com/joshivignesh/expenseflow-microservices/actions/workflows/cd.yml)
[![.NET](https://img.shields.io/badge/.NET-8.0-512BD4?logo=dotnet&logoColor=white)](https://dotnet.microsoft.com)
[![React](https://img.shields.io/badge/React-18-61DAFB?logo=react&logoColor=black)](https://react.dev)
[![Docker](https://img.shields.io/badge/Docker-Compose-2496ED?logo=docker&logoColor=white)](https://www.docker.com)
[![RabbitMQ](https://img.shields.io/badge/RabbitMQ-Event%20Bus-FF6600?logo=rabbitmq&logoColor=white)](https://www.rabbitmq.com)
[![License: MIT](https://img.shields.io/badge/License-MIT-22c55e.svg)](LICENSE)

<br/>

**[ğŸš€ Live Demo](https://expenseflow.vercel.app)** Â· **[ğŸ“– API Docs](https://expenseflow-gateway.onrender.com/swagger)** Â· **[ğŸ—ï¸ Architecture](docs/architecture.md)** Â· **[ğŸ“‹ ADRs](docs/adr/)**

<br/>

</div>

---

## ğŸ“Œ What Is This?

**ExpenseFlow** is a **production-grade, cloud-native expense management platform** built with enterprise .NET patterns â€” the same architectural approach used at scale by teams at Microsoft, ThoughtWorks, and the financial services industry.

This project demonstrates:

- **Domain-Driven Design (DDD)** â€” Aggregate Roots, Value Objects, Domain Events, Bounded Contexts
- **CQRS with MediatR** â€” Commands use EF Core + rich domain; Queries use Dapper for raw SQL performance
- **Event-Driven Microservices** â€” Asynchronous communication via RabbitMQ Integration Events
- **Clean Architecture** â€” Strict layer dependency rules enforced by automated architecture tests
- **Cloud-Native Resilience** â€” Polly retry/circuit breaker, health checks, OpenTelemetry distributed tracing

> ğŸ“š Architecture follows Microsoft's official guides: [Microservices for .NET](https://learn.microsoft.com/dotnet/architecture/microservices/), [Cloud Native .NET](https://learn.microsoft.com/dotnet/architecture/cloud-native/), and [ASP.NET Core Architecture](https://learn.microsoft.com/dotnet/architecture/modern-web-apps-azure/)

---

## ğŸ—ï¸ System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    React 18 + TypeScript Frontend                    â”‚
â”‚               Redux Toolkit Â· Tailwind CSS Â· React Query             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚ HTTPS
                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Ocelot API Gateway  :5000                         â”‚
â”‚         JWT Validation Â· Rate Limiting Â· Correlation IDs             â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚               â”‚                  â”‚            â”‚
       â–¼               â–¼                  â–¼            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Identity    â”‚ â”‚   Expense    â”‚ â”‚Notificationâ”‚ â”‚    Report      â”‚
â”‚  Service     â”‚ â”‚   Service    â”‚ â”‚  Service   â”‚ â”‚    Service     â”‚
â”‚   :5001      â”‚ â”‚   :5002      â”‚ â”‚   :5003    â”‚ â”‚    :5004       â”‚
â”‚              â”‚ â”‚              â”‚ â”‚            â”‚ â”‚                â”‚
â”‚  DDD + CQRS  â”‚ â”‚  DDD + CQRS  â”‚ â”‚  Consumer  â”‚ â”‚  Read-heavy    â”‚
â”‚  JWT + Auth  â”‚ â”‚  Approvals   â”‚ â”‚  SendGrid  â”‚ â”‚  QuestPDF      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                â”‚               â–²
       â–¼                â–¼               â”‚ Integration Events
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚SQL Serverâ”‚    â”‚SQL Serverâ”‚    â”‚    RabbitMQ     â”‚
  â”‚(Identity)â”‚    â”‚(Expense) â”‚    â”‚   Event Bus     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                  â”‚  Redis   â”‚
                  â”‚  Cache   â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Microservices at a Glance

| Service | Pattern | Key Tech | Port |
|---|---|---|---|
| **Identity.Service** | DDD + CQRS | JWT, Refresh Tokens, EF Core | 5001 |
| **Expense.Service** | DDD + CQRS + Events | MediatR, Dapper, RabbitMQ, Redis | 5002 |
| **Notification.Service** | Consumer | RabbitMQ, SendGrid, HTML Templates | 5003 |
| **Report.Service** | Query-only | Dapper, QuestPDF, Analytics | 5004 |
| **API Gateway** | Reverse Proxy | Ocelot, Polly, JWT Validation | 5000 |

---

## ğŸ§  Architecture Deep Dive

### Domain-Driven Design

Each microservice is its own **Bounded Context** with a fully isolated domain model. The `Expense` aggregate root is the centrepiece:

```csharp
// âœ… Rich domain model â€” state changes via explicit domain methods
// Source: Microsoft Microservices Guide, Chapter 7
public class Expense : AggregateRoot
{
    public Money Amount { get; private set; }        // Value Object
    public ExpenseStatus Status { get; private set; } // Private setter
    public string SubmittedById { get; private set; }

    // Domain method â€” enforces business rules + raises Domain Event internally
    public void Approve(string approverId, string comment)
    {
        if (Status != ExpenseStatus.Pending)
            throw new InvalidExpenseStateException(Id, Status, "Approve");

        Status = ExpenseStatus.Approved;
        AddDomainEvent(new ExpenseApprovedEvent(Id, approverId, comment));
    }

    // âŒ No public setters. No: expense.Status = ExpenseStatus.Approved;
}
```

### CQRS â€” Write Side (Commands via EF Core + Domain)

```csharp
// Command â€” immutable C# record
public sealed record ApproveExpenseCommand(Guid ExpenseId, string ApproverId, string Comment)
    : IRequest<bool>;

// Handler â€” orchestrates, delegates logic to domain
public class ApproveExpenseCommandHandler : IRequestHandler<ApproveExpenseCommand, bool>
{
    public async Task<bool> Handle(ApproveExpenseCommand cmd, CancellationToken ct)
    {
        var expense = await _repository.GetByIdAsync(cmd.ExpenseId, ct);
        expense.Approve(cmd.ApproverId, cmd.Comment); // Domain logic lives HERE
        await _repository.UnitOfWork.SaveEntitiesAsync(ct);
        return true;
    }
}
```

### CQRS â€” Read Side (Queries via Dapper â€” raw SQL performance)

```csharp
// Query handler bypasses domain entirely â€” max read performance
// As recommended in Microsoft's eShopOnContainers reference
public class GetExpensesByUserHandler : IRequestHandler<GetExpensesByUserQuery, PagedResult<ExpenseSummaryViewModel>>
{
    public async Task<PagedResult<ExpenseSummaryViewModel>> Handle(GetExpensesByUserQuery query, CancellationToken ct)
    {
        const string sql = @"
            SELECT e.Id, e.Amount_Value AS Amount, e.Currency, e.Category,
                   e.Status, e.SubmittedAt, e.Description
            FROM Expenses e
            WHERE e.SubmittedById = @UserId AND e.Status = @Status
            ORDER BY e.SubmittedAt DESC
            OFFSET @Skip ROWS FETCH NEXT @Take ROWS ONLY";

        var results = await _dbConnection.QueryAsync<ExpenseSummaryViewModel>(sql, query);
        return results.ToPagedResult(query.Page, query.PageSize);
    }
}
```

### MediatR Pipeline Behaviors (Cross-cutting Concerns)

```
HTTP Request
    â†“
Controller.Send(command)
    â†“
[LoggingBehavior]       â† Logs command name, userId, duration
    â†“
[ValidationBehavior]    â† FluentValidation â€” fails fast before touching domain
    â†“
[TransactionBehavior]   â† Wraps handler in DB transaction
    â†“
CommandHandler          â† Pure business orchestration
    â†“
Domain.Method()         â† Business rules + raises Domain Events
    â†“
Repository.Save()       â† EF Core persists, publishes integration events
```

### Event-Driven Integration

Domain Events stay inside a service. Integration Events cross service boundaries via RabbitMQ:

```
Expense Service                          Notification Service
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
expense.Approve()
 â””â”€â–º ExpenseApprovedDomainEvent (internal)
      â””â”€â–º CommandHandler publishes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  ExpenseApprovedConsumer
           ExpenseApprovedIntegrationEvent                            â””â”€â–º EmailService.Send()
           to RabbitMQ                                                      â””â”€â–º SendGrid API
```

### Resilience with Polly

```csharp
// Every outbound HTTP call wrapped in retry + circuit breaker
// Source: Cloud-Native .NET Guide, Chapter 6
services.AddHttpClient<IIdentityClient, IdentityClient>()
    .AddPolicyHandler(GetRetryPolicy())        // Exponential backoff: 1s, 2s, 4s
    .AddPolicyHandler(GetCircuitBreakerPolicy()); // Open circuit after 5 failures, reset after 30s
```

### Health Checks (Kubernetes-ready)

Every service exposes two endpoints:

| Endpoint | Purpose | Checks |
|---|---|---|
| `GET /health/live` | Liveness â€” is the process alive? | Always 200 OK |
| `GET /health/ready` | Readiness â€” can it take traffic? | DB connectivity + Redis ping |

---

## ğŸ“ Repository Structure

```
expenseflow-microservices/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ ExpenseFlow.Identity/          # 4-layer DDD: Domain/Application/Infrastructure/API
â”‚   â”‚   â”œâ”€â”€ ExpenseFlow.Expense/           # Core bounded context â€” richest domain model
â”‚   â”‚   â”œâ”€â”€ ExpenseFlow.Notification/      # Event consumer â€” simple, no domain layer needed
â”‚   â”‚   â””â”€â”€ ExpenseFlow.Report/            # Read-only service â€” Dapper + QuestPDF
â”‚   â”œâ”€â”€ gateway/
â”‚   â”‚   â””â”€â”€ ExpenseFlow.Gateway/           # Ocelot routing, JWT validation, rate limiting
â”‚   â””â”€â”€ frontend/
â”‚       â””â”€â”€ expenseflow-ui/                # React 18 + TypeScript + Tailwind + Redux Toolkit
â”œâ”€â”€ shared/
â”‚   â””â”€â”€ ExpenseFlow.Shared/                # AggregateRoot, Entity, ValueObject base classes
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ docker-compose.yml
â”‚   â””â”€â”€ nginx/nginx.conf
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ ExpenseFlow.Expense.UnitTests/     # Domain logic â€” no mocking of infrastructure
â”‚   â”œâ”€â”€ ExpenseFlow.Identity.UnitTests/
â”‚   â”œâ”€â”€ ExpenseFlow.Expense.IntegrationTests/  # Real DB via TestContainers
â”‚   â””â”€â”€ ExpenseFlow.Architecture.Tests/   # ArchUnitNET â€” enforces layer rules in CI
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ architecture.md
â”‚   â””â”€â”€ adr/                              # Architecture Decision Records
â”œâ”€â”€ .github/workflows/
â”‚   â”œâ”€â”€ ci.yml                            # Build â†’ Test â†’ Lint â†’ Arch tests on every PR
â”‚   â””â”€â”€ cd.yml                            # Docker build â†’ push â†’ deploy on merge to main
â””â”€â”€ README.md
```

---

## ğŸš€ Running Locally

### Prerequisites

- [.NET 8 SDK](https://dotnet.microsoft.com/download)
- [Docker Desktop](https://www.docker.com/products/docker-desktop)
- [Node.js 20+](https://nodejs.org)

### One-Command Startup

```bash
git clone https://github.com/joshivignesh/expenseflow-microservices.git
cd expenseflow-microservices
docker-compose up --build
```

That's it. Docker Compose starts all services, databases, Redis, and RabbitMQ.

| URL | What |
|---|---|
| `http://localhost:3000` | React Frontend |
| `http://localhost:5000` | API Gateway (Swagger UI) |
| `http://localhost:15672` | RabbitMQ Management (guest/guest) |
| `http://localhost:5001/health/ready` | Identity Service Health |
| `http://localhost:5002/health/ready` | Expense Service Health |

### Seeded Test Accounts

| Role | Email | Password |
|---|---|---|
| Admin | `admin@expenseflow.com` | `Admin@123` |
| Employee | `employee@expenseflow.com` | `Pass@123` |
| Manager | `manager@expenseflow.com` | `Pass@123` |

---

## ğŸ§ª Running Tests

```bash
# All tests
dotnet test

# Unit tests only (fast â€” no external dependencies)
dotnet test --filter Category=Unit

# Integration tests (requires Docker for TestContainers)
dotnet test --filter Category=Integration

# Architecture tests â€” enforces DDD layer rules
dotnet test tests/ExpenseFlow.Architecture.Tests/
```

**Architecture test example** â€” this runs in CI and will fail if anyone imports EF Core into the Domain layer:

```csharp
[Fact]
public void DomainLayer_Should_Not_Depend_On_Infrastructure()
{
    var result = Types.InAssembly(DomainAssembly)
        .ShouldNot()
        .HaveDependencyOn("Microsoft.EntityFrameworkCore")
        .GetResult();

    result.IsSuccessful.Should().BeTrue();
}
```

---

## ğŸŒ Deployment

All services deployed for free using:

| Component | Platform | Status |
|---|---|---|
| API Gateway + Microservices | Render.com | [![Render](https://img.shields.io/badge/Render-deployed-46E3B7?logo=render)](https://render.com) |
| React Frontend | Vercel | [![Vercel](https://img.shields.io/badge/Vercel-deployed-000000?logo=vercel)](https://vercel.com) |
| PostgreSQL | Railway.app | Running |
| Redis | Upstash | Running |
| RabbitMQ | CloudAMQP | Running |

**CI/CD Pipeline:**

```
Push to feature/* â†’ CI runs (build + test + arch checks)
                          â†“
Merge to develop â†’ Integration tests
                          â†“
Merge to main   â†’ Docker build â†’ Docker Hub push â†’ Render deploy
```

---

## ğŸ“ Key Design Decisions

See [Architecture Decision Records](docs/adr/) for full context. Summary:

| Decision | Choice | Why |
|---|---|---|
| CQRS read strategy | **Dapper** (not EF) | Raw SQL performance; no domain constraints on reads |
| Messaging | **RabbitMQ** (not HTTP) | Services stay decoupled; failures don't cascade |
| Validation | **MediatR Pipeline** (not controller) | Centralized â€” works for any entry point |
| DDD scope | **Expense + Identity only** | Notification/Report are simple â€” DDD overkill there |
| Integration testing | **TestContainers** | Tests run against real DB â€” not mocks |
| Layer enforcement | **ArchUnitNET in CI** | Rules that aren't automated get broken eventually |

---

## ğŸ› ï¸ Tech Stack

<table>
<tr>
<td><strong>Backend</strong></td>
<td>ASP.NET Core 8 Â· C# 12 Â· Entity Framework Core 8 Â· Dapper</td>
</tr>
<tr>
<td><strong>Architecture</strong></td>
<td>DDD Â· CQRS Â· Clean Architecture Â· Event-Driven</td>
</tr>
<tr>
<td><strong>Messaging</strong></td>
<td>RabbitMQ via MassTransit</td>
</tr>
<tr>
<td><strong>Caching</strong></td>
<td>Redis via StackExchange.Redis</td>
</tr>
<tr>
<td><strong>Resilience</strong></td>
<td>Polly (Retry + Circuit Breaker) Â· IHttpClientFactory</td>
</tr>
<tr>
<td><strong>Observability</strong></td>
<td>Serilog (structured JSON) Â· OpenTelemetry Â· Health Checks</td>
</tr>
<tr>
<td><strong>Auth</strong></td>
<td>JWT Bearer + Refresh Token Rotation</td>
</tr>
<tr>
<td><strong>Gateway</strong></td>
<td>Ocelot (routing, rate limiting, auth)</td>
</tr>
<tr>
<td><strong>Frontend</strong></td>
<td>React 18 Â· TypeScript Â· Redux Toolkit Â· Tailwind CSS Â· Recharts</td>
</tr>
<tr>
<td><strong>Testing</strong></td>
<td>xUnit Â· Moq Â· FluentAssertions Â· TestContainers Â· ArchUnitNET</td>
</tr>
<tr>
<td><strong>DevOps</strong></td>
<td>Docker Â· Docker Compose Â· GitHub Actions Â· Render Â· Vercel</td>
</tr>
<tr>
<td><strong>Reports</strong></td>
<td>QuestPDF Â· Dapper analytics queries</td>
</tr>
</table>

---

## ğŸ“Š Features

- **Submit expenses** with line items, categories, receipt URLs, and period ranges
- **Approval workflow** â€” Managers approve or reject with comments; employees notified via email
- **Dashboard** â€” Expense totals, category breakdown chart, pending approvals count
- **PDF Reports** â€” Monthly expense summaries downloadable as formatted PDF
- **Admin panel** â€” Full expense management, user management, audit trails
- **Role-based access** â€” Employee, Manager, Admin roles enforced at gateway + service level
- **Pagination & filtering** â€” Filter by status, date range, category, amount
- **Correlation tracking** â€” Every request traceable across all services via `X-Correlation-Id`

---

## ğŸ‘¤ Author

**Vignesh Joshi** â€” .NET Full Stack Developer

[![LinkedIn](https://img.shields.io/badge/LinkedIn-joshivignesh-0077B5?logo=linkedin)](https://linkedin.com/in/joshivignesh)
[![GitHub](https://img.shields.io/badge/GitHub-joshivignesh-181717?logo=github)](https://github.com/joshivignesh)
[![Twitter](https://img.shields.io/badge/Twitter-@vigneshjoshi-1DA1F2?logo=twitter)](https://twitter.com/vigneshjoshi)

---

## ğŸ“„ License

MIT â€” see [LICENSE](LICENSE)

---

<div align="center">

*Built with the patterns from Microsoft's .NET Architecture Guides*
*eShopOnContainers Â· Domain-Driven Design Â· Cloud-Native .NET*

</div>
